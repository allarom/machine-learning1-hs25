---
title: "Used Cars – Applied ML Project"
output: html_document
---

<!-- Load libraries -->
```{r setup, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(here)
```

# About the Dataset (Summary)

The Used Car Price Prediction dataset contains 4,009 vehicle listings collected from the automotive marketplace cars.com.
Each row represents a unique car and includes nine key attributes relevant to pricing and vehicle characteristics.
Dataset is taken from Kaggle: https://www.kaggle.com/datasets/taeefnajib/used-car-price-prediction-dataset

The dataset provides information on:

**Brand and model** – manufacturer and specific vehicle model

**Model year ** – age of the car, influencing depreciation

**Mileage** – an indicator of usage and wear

**Fuel type** – e.g., gasoline, diesel, electric, hybrid

**Engine type** – performance and efficiency characteristics

**Transmission** – automatic or manual

**Exterior/interior colors** – aesthetic properties

**Accident history** – whether the car has previously been damaged

**Clean title** – legal/ownership status

**Price** – listed price of the vehicle

Overall, the dataset offers a structured overview of key features that influence used car valuation. It is well-suited for analytical tasks such as understanding pricing drivers, exploring consumer preferences, and building predictive models for vehicle prices.
# Raw data

We load the original CSV directly from the project data folder using `here()` so paths work regardless of the working directory.

```{r load-raw, message=FALSE}
raw_path <- here("data", "raw", "used_cars.csv")
cars_raw <- readr::read_csv(raw_path, show_col_types = FALSE)
```

Basic structure and summary statistics of the raw dataset:

```{r raw-summary}
glimpse(cars_raw)
```

# Exploratory Data Analysis

We base the EDA on the engineered dataset (`data/processed/used_cars_features.csv`) that keeps cleaned numeric fields and derived features like age, mileage in thousands, and accident flags.

```{r load-features, message=FALSE}
features_path <- here("data", "processed", "used_cars_features.csv")
cars <- readr::read_delim(features_path, delim = ";", show_col_types = FALSE)
```

## Key descriptive values

```{r descriptive-table, message=FALSE, echo=FALSE}
num_summary <- tibble::tibble(
  variable = c("price_dollar", "log_price", "age", "milage_k", "horsepower"),
  median   = c(median(cars$price_dollar), median(cars$log_price), median(cars$age), median(cars$milage_k), median(cars$horsepower)),
  mean     = c(mean(cars$price_dollar), mean(cars$log_price), mean(cars$age), mean(cars$milage_k), mean(cars$horsepower)),
  p25      = c(quantile(cars$price_dollar, 0.25), quantile(cars$log_price, 0.25), quantile(cars$age, 0.25), quantile(cars$milage_k, 0.25), quantile(cars$horsepower, 0.25)),
  p75      = c(quantile(cars$price_dollar, 0.75), quantile(cars$log_price, 0.75), quantile(cars$age, 0.75), quantile(cars$milage_k, 0.75), quantile(cars$horsepower, 0.75)),
  sd       = c(sd(cars$price_dollar), sd(cars$log_price), sd(cars$age), sd(cars$milage_k), sd(cars$horsepower)),
  min      = c(min(cars$price_dollar), min(cars$log_price), min(cars$age), min(cars$milage_k), min(cars$horsepower)),
  max      = c(max(cars$price_dollar), max(cars$log_price), max(cars$age), max(cars$milage_k), max(cars$horsepower))
)

knitr::kable(num_summary, digits = 2, caption = "Key numeric feature summaries")
```

```{r accident-summary, message=FALSE, echo=FALSE}
accident_tbl <- as.data.frame(table(cars$accident), stringsAsFactors = FALSE) |>
  dplyr::rename(accident = Var1, n = Freq) |>
  dplyr::mutate(share = n / sum(n))

knitr::kable(accident_tbl, digits = 2, caption = "Accident history distribution")
```

Median listing sits around \$28k, with the middle 50% between roughly \$15.5k and \$47k, while the maximum reaches \$650k—explaining the heavy right tail. Median age is 9 years (IQR: 6–14), typical mileage is about 63k miles (IQR: 30k–103k), and horsepower clusters around 310 HP (IQR: 248–400). About 28% of cars report an accident or damage, a meaningful factor for pricing.

## Price distribution (raw and log)

```{r price-raw, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "price_distribution_raw.png"))
```

Raw prices are extremely right-skewed, with most listings below \$80k but a long tail of luxury and exotic vehicles. Modeling on this scale would be dominated by a few high-price outliers.

```{r price-log, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "price_distribution.png"))
```

Log transformation produces a more bell-shaped distribution and stabilizes variance, making linear-style models and visual comparisons more reliable.

## Depreciation by age and fuel type

```{r age-price, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "age_vs_price.png"))
```

Prices decline with age across fuels. Electric listings start high but show the sharpest early drop; diesel holds comparatively high prices across ages (though the diesel sample is small), and gasoline sits lower overall.

## Price spread across top brands

```{r brand-price, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "brand_price_boxplots.png"))
```

Among the 12 most common brands, Porsche leads on median price, followed by Land Rover and Mercedes-Benz; Volume brands (Toyota, Nissan, Jeep) cluster lower with tighter spreads, while some (Chevrolet, Ford) span broader lineups.

## Mileage impact by transmission

```{r milage-price, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "milage_vs_price.png"))
```

Higher mileage correlates with lower prices. We use a loess smoother (not a straight trendline) and cap the x-axis at 250k miles to reduce the influence of extreme outliers; automatics show a steady decline, and the smaller manual subset is noisier but similar in direction.

## Horsepower premium

```{r hp-price, echo=FALSE, out.width="85%"}
knitr::include_graphics(here("report", "plots", "horsepower_vs_price.png"))
```

Price rises with horsepower, especially from ~250 HP upward; we cap horsepower at 700 to avoid a handful of ultra-high-HP outliers from distorting the loess smoother, so the trend reflects the bulk of the market rather than extreme sports models.

## Accident history effect

```{r accident-price, echo=FALSE, out.width="70%"}
knitr::include_graphics(here("report", "plots", "accident_vs_price.png"))
```

Cars with reported accidents trade at a clear discount relative to clean histories, even after log-scaling prices, confirming accident history as an important predictor.

## SVM model results

We fit radial-kernel SVM regressors on `log_price` using both `e1071::svm` and `kernlab` (via `caret::train`). Both models use the same 80/20 train-test split; hyperparameters are tuned by cross-validation and evaluated on the hold-out test set below.

```{r svm-metrics, message=FALSE}
svm_metrics <- readr::read_csv(
  here("report", "models", "svm", "svm_log_price_metrics.csv"),
  show_col_types = FALSE
)

svm_best <- readr::read_lines(here("report", "models", "svm", "svm_best_model.txt"))[1]

svm_metrics_wide <- svm_metrics |>
  tidyr::pivot_wider(names_from = .metric, values_from = .estimate)

knitr::kable(svm_metrics_wide, digits = 3, caption = "Test metrics for SVM variants (target: log_price)")
```

The `e1071` radial SVM is best by RMSE (~0.290) and R² (~0.868), outperforming the kernlab variant on this split. SVMs do not yield straightforward coefficient interpretations; they learn support vectors and decision functions in a transformed feature space. To understand feature effects you would rely on downstream tools (e.g., partial dependence or SHAP), but within this report we focus on comparative error metrics and note that the tuned radial kernel captures non-linear relationships beyond the linear/log models. 

Cross-validation setup: both SVMs were tuned with 3-fold cross validation on the training set (same 80/20 split for both). `e1071::tune()` searched a compact grid of `cost` and `gamma`; `caret::train(method = "svmRadial")` searched a grid of `C` and `sigma`. Final metrics shown above are from the untouched test set, so cross validation was only for hyperparameter selection.

`r svm_best`

```{r svm-pred-vs-true, fig.width=11, fig.height=5.5, message=FALSE, echo=FALSE}
pred_e1071 <- readr::read_delim(
  here("report", "models", "svm", "svm_log_price_e1071_predictions.csv"),
  delim = ";",
  show_col_types = FALSE
) |>
  dplyr::mutate(model = "e1071_radial")

pred_kern <- readr::read_delim(
  here("report", "models", "svm", "svm_log_price_kernlab_predictions.csv"),
  delim = ";",
  show_col_types = FALSE
) |>
  dplyr::mutate(model = "kernlab_radial")

plot_svm <- function(df, title) {
  df <- df |>
    dplyr::mutate(resid = pred_log_price - log_price)

  ggplot2::ggplot(df, ggplot2::aes(x = log_price, y = pred_log_price, color = resid)) +
    ggplot2::geom_point(alpha = 0.7, size = 1.4) +
    ggplot2::geom_smooth(method = "loess", se = FALSE, color = "black", linewidth = 0.8) +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") +
    ggplot2::coord_equal() +
    ggplot2::scale_color_gradient2(
      low = "#B91C1C", mid = "#CBD5E1", high = "#15803D",
      midpoint = 0,
      name = "Residual price (predicted  - true)\nred = under-prediction, grey = correct, green = over-prediction"
    ) +
    ggplot2::labs(
      title = title,
      x = "True log(price)",
      y = "Predicted log(price)"
    ) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(
      legend.position = "none",
      plot.title.position = "plot",
      plot.title = ggplot2::element_text(hjust = 0, vjust= -20)
    )
}

p1 <- plot_svm(pred_e1071, "e1071 radial SVM:\n predicted vs true")
p2 <- plot_svm(pred_kern, "kernlab radial SVM:\n predicted vs true")

# Standalone legend using the same residual scale
legend_plot <- ggplot2::ggplot(
  data.frame(resid = c(-0.5, 0, 0.5), x = 1, y = 1),
  ggplot2::aes(x = x, y = y, color = resid)
) +
  ggplot2::geom_point(alpha = 0) + # invisible points; legend only
  ggplot2::scale_color_gradient2(
    low = "#B91C1C", mid = "#CBD5E1", high = "#15803D",
    midpoint = 0,
    name = "Residual price (predicted  - true)\nred = under-prediction, grey = correct, green = over-prediction"
  ) +
  ggplot2::guides(color = ggplot2::guide_colorbar(barheight = unit(60, "pt"))) +
  ggplot2::theme_void() +
  ggplot2::theme(legend.position = "right")

patchwork::wrap_plots(
  p1,
  p2,
  legend_plot,
  ncol = 3,
  widths = c(1, 1, 0.22)
)
```

## Neural network results

Two regressors on `log_price`: a caret `nnet` (with dummying + scaling, 3-fold cross validation over size/decay) and a manual `neuralnet` (shallow hidden layer). Metrics below come from the test split; cross validation was used only for tuning.

```{r nn-metrics, message=FALSE}
nn_metrics <- readr::read_csv(
  here("report", "models", "nn", "nn_log_price_metrics.csv"),
  show_col_types = FALSE
)

nn_best <- readr::read_lines(here("report", "models", "nn", "nn_best_model.txt"))[1]

nn_metrics_wide <- nn_metrics |>
  tidyr::pivot_wider(names_from = .metric, values_from = .estimate)

knitr::kable(nn_metrics_wide, digits = 3, caption = "Test metrics for NN variants (target: log_price)")
```

`r nn_best` — the manual `neuralnet` edge is small (RMSE ≈ 0.388 vs. 0.392), so both nets are in a similar error band; the manual net slightly reduces bias on the high end (see fewer large positive residuals).

```{r nn-pred-vs-true, fig.width=11, fig.height=5.5, message=FALSE, echo=FALSE}
pred_caret <- readr::read_delim(
  here("report", "models", "nn", "nn_log_price_caret_predictions.csv"),
  delim = ";",
  show_col_types = FALSE
) |>
  dplyr::mutate(model = "caret_nnet")

pred_manual <- readr::read_delim(
  here("report", "models", "nn", "nn_log_price_neuralnet_predictions.csv"),
  delim = ";",
  show_col_types = FALSE
) |>
  dplyr::mutate(model = "neuralnet_manual")

plot_nn <- function(df, title) {
  df <- df |>
    dplyr::mutate(resid = pred_log_price - log_price)

  ggplot2::ggplot(df, ggplot2::aes(x = log_price, y = pred_log_price, color = resid)) +
    ggplot2::geom_point(alpha = 0.7, size = 1.4) +
    ggplot2::geom_smooth(method = "loess", se = FALSE, color = "black", linewidth = 0.8) +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") +
    ggplot2::coord_equal() +
    ggplot2::scale_color_gradient2(
      low = "#B91C1C", mid = "#CBD5E1", high = "#15803D",
      midpoint = 0,
      name = "Residual (pred - true)"
    ) +
    ggplot2::labs(
      title = title,
      x = "True log(price)",
      y = "Predicted log(price)"
    ) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(
      legend.position = "none",
      plot.title.position = "plot",
      plot.title = ggplot2::element_text(hjust = 0, vjust= -20)
    )
}

p1 <- plot_nn(pred_caret, "caret nnet: predicted vs true")
p2 <- plot_nn(pred_manual, "neuralnet manual: predicted vs true")

legend_plot_nn <- ggplot2::ggplot(
  data.frame(resid = c(-0.5, 0, 0.5), x = 1, y = 1),
  ggplot2::aes(x = x, y = y, color = resid)
) +
  ggplot2::geom_point(alpha = 0) +
  ggplot2::scale_color_gradient2(
    low = "#B91C1C", mid = "#CBD5E1", high = "#15803D",
    midpoint = 0,
    name = "Residual (pred - true)\nred = under-prediction, grey = correct, green = over-prediction"
  ) +
  ggplot2::guides(color = ggplot2::guide_colorbar(barheight = unit(60, "pt"))) +
  ggplot2::theme_void() +
  ggplot2::theme(legend.position = "right")

patchwork::wrap_plots(
  p1,
  p2,
  legend_plot_nn,
  ncol = 3,
  widths = c(1, 1, 0.22)
)
```



## 4. Linear regression model


In Section 3 we saw that price is strongly right-skewed and that log(price) has an approximately 
linear relationship with age. Based on this, we now fit a linear regression model with log(price) as response.

The goal is not primarily to build the most accurate predictor, 
but to understand which factors drive used-car prices and in which direction.

We model the natural logarithm of the price instead of the raw price because:

- prices are strictly positive and strongly right–skewed,
- taking the log makes the distribution more symmetric,
- the linear model assumptions (linear relationship, constant variance of the
  residuals) are usually better satisfied on the log scale,
- coefficients can be interpreted approximately as *percentage* effects.


### 4.1. Model specification

We use the feature dataset created in the previous step
(`data/processed/used_cars_features.csv`) and fit the following multiple
linear regression model on the log-price:

`log_price ~ age + milage_k + accident_bin + brand + fuel_type + transmission + ext_col + int_col`

Here

- `log_price` is the natural logarithm of the car price in dollars
  (the target variable / response).
- `age` is the car age in years.
- `milage_k` is the mileage in thousands of miles.
- `accident_bin` is a binary variable  
  (0 = no accident reported, 1 = at least one accident or damage reported).
- `brand`, `fuel_type`, `transmission`, `ext_col` and `int_col` are
  categorical predictors and are represented in the model by dummy variables
  with one reference category each.
- The error term (residual) captures the remaining variation not explained by
  the predictors.

The coefficients of this model measure how much the expected log-price changes
when we increase a numeric predictor by one unit (or switch a dummy variable
from 0 to 1), while *keeping all other variables fixed*.


### 4.2 Estimation and overall performance

We implement and fit the model by sourcing the script
`src/04_model_linear.R`, which

1. loads the feature data (`used_cars_features.csv`),
2. selects the variables listed above and removes rows with missing values,
3. fits the linear model with `stats::lm(...)`, and
4. computes the root mean squared error (RMSE) and \(R^2\) on the log-price
   scale and adds predictions back to the data.

```{r linear-fit, message=FALSE, warning=FALSE}
# Fit the baseline linear regression model and prepare lm_linear_data
source(here::here("src", "04_model_linear.R"))

# Show a compact summary of the model 
broom::tidy(lm_linear) |> 
  dplyr::slice(1:10)  # show only first 10 coefficients

```

### 4.3 Interpretation of selected coefficients

Because the model is fitted on the log(price) scale, each coefficient can be
read approximately as a **percentage change in price** when we increase that
variable by one unit (or switch a dummy variable from 0 to 1), while keeping
all other variables fixed. Roughly, a coefficient of −0.06 means “about −6 %”,
a coefficient of +0.20 means “about +22 %”, and so on.

Below we interpret a few selected coefficients from the model.

- **Age (coefficient ≈ −0.058)**  
  Holding all other variables constant, increasing the age of a car by one year
  reduces the expected price by about **6 %** (exp(−0.058) ≈ 0.94).  
  → Older cars are substantially cheaper, as expected.

- **Mileage in thousands (coefficient ≈ −0.006)**  
  An additional 1,000 miles reduces the expected price by roughly **0.6 %**.  
  → The effect of mileage is noticeable but smaller than the effect of age.

- **Accident history (`accident_bin`, coefficient ≈ −0.080)**  
  `accident_bin = 1` indicates that at least one accident or damage has been
  reported. Compared to a car with no accident history (`accident_bin = 0`),
  the expected price is lower by about **8 %**.  
  → Cars with an accident history sell for clearly lower prices.

- **Brand examples**  
  The brand coefficients show how each brand differs from the (omitted)
  reference brand, holding age, mileage, accident history and all other
  variables constant.

  - `brandBMW` (coefficient ≈ 0.28): price is about **30 % higher** than for
    the reference brand.  
    → BMW cars are noticeably more expensive, even after controlling for other
    factors.

  - `brandFerrari` (coefficient ≈ 1.82): price is more than **six times
    higher** (over +500 %) than for the reference brand.  
    → Ferrari appears as an extreme premium brand in this dataset.

- **Fuel type example (`fuel_typeElectric`, coefficient ≈ −0.79)**  
  For purely electric cars, the coefficient corresponds to a price that is
  roughly **55 % lower** than for the reference fuel type, given the same age,
  mileage, brand etc.  
  → In this sample, electric cars are priced clearly below comparable vehicles
  with the reference fuel type (possibly due to different model mix, range
  concerns, or incentives on combustion cars).

- **Transmission (`transmissionManual`, coefficient ≈ 0.20)**  
  Manual transmission has a coefficient of about 0.20, which translates to
  prices that are roughly **20–22 % higher** than for the reference
  transmission type.  
  → Cars with manual transmission are on average more expensive in this sample.

Overall, the signs and magnitudes of the coefficients are plausible: older and
higher-mileage cars and cars with accidents are cheaper, while premium brands
and certain configurations (e.g. BMW, Ferrari) command much higher prices.
With an \(R^2\) of about 0.75 on the log-price scale, the model explains a
large share of the variation in used car prices, even though there is still
substantial unexplained variability.


### 4.4. Relationship between age and log-price

To visualise the effect of age in the linear model, we plot log-price against
age and add a fitted linear trend line.


```{r age-log-plot, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(lm_linear_data,
       aes(x = age, y = log_price)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(
    x = "Age (years)",
    y = "log(price)",
    title = "Relationship between age and log(price)"
  )
```

The plot shows the expected negative relationship: older cars tend to have a
lower log-price. In our model, the age coefficient is about −0.058, which means
that, holding all other variables constant, one additional year of age reduces
the expected price by roughly 6 % (because exp(−0.058) ≈ 0.94).


### 4.5. Residual diagnostics

To check whether the linear model assumptions are roughly satisfied, we plot the
residuals against the fitted (predicted) log-prices. Ideally, the points are
scattered randomly around zero without a clear pattern.

```{r linear-residual-plot, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(lm_linear_data,
       aes(x = pred_log_price, y = resid_log_price)) +
  geom_point(alpha = 0.4) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    x = "Predicted log(price)",
    y = "Residual (observed - predicted)",
    title = "Residuals vs. predicted values"
  )
```
In our plot, the residuals are roughly centred around zero with no strong
curvature. There is some increase in spread for higher predicted prices, but
overall the linear model assumptions appear acceptable.


### 4.6 Conclusions (linear regression)

Overall, the linear regression on log(price) provides a simple and
interpretable summary of the main price drivers in this dataset. Age and
mileage have the expected negative impact on prices, while an accident
history leads to a price discount of roughly 8 %. Premium brands such as
BMW and especially Ferrari command large price premia, even after
controlling for age, mileage and fuel type. The model explains about
75 % of the variance in log-prices, which is quite high for real-world
data, but the residual plot also shows that there is still substantial
unexplained variability. For a client, this model could already be used
as a rough pricing guideline, but more advanced models (e.g. with
interactions or nonlinear effects) might capture the remaining structure
in the data even better.




## 6. Generalized Linear Model — Poisson

A Poisson GLM is typically used when the **response variable is a count**
(non-negative integers). Because this dataset does not contain a natural event
count, we use a pragmatic proxy: **mileage in thousands** (`milage_k`),
converted to an integer “count-like” variable (`milage_k_count`).  
This section mainly demonstrates the **Poisson GLM workflow and interpretation**.

### 6.1 Model specification

We model the expected mileage count (in thousands) using a Poisson GLM with a log link:

`milage_k_count ~ age + accident_bin + brand + fuel_type + transmission + ext_col + int_col`

In a Poisson GLM with log link:

- Response: `milage_k_count` (non-negative integer proxy)
- Predictors: age, accident history, and categorical vehicle characteristics
- Link: `log( E[milage_k_count] ) = linear predictor`

So coefficients are interpreted **multiplicatively**:  
`exp(beta)` is the factor change in the expected count for a one-unit increase (or dummy switch),
holding other variables fixed.

### 6.2 Estimation and overall performance

We fit the Poisson GLM by sourcing `src/06_model_glm_poisson.R`, which:
1) loads the feature data,  
2) creates `milage_k_count`,  
3) fits a Poisson GLM with log link, and  
4) adds predictions/residuals back to the data.

```{r poisson-fit, message=FALSE, warning=FALSE}
source(here::here("src", "06_model_glm_poisson.R"))

# compact coefficient table incl. significance stars
poisson_tbl <- broom::tidy(glm_poisson) |>
  dplyr::mutate(
    signif = dplyr::case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01  ~ "**",
      p.value < 0.05  ~ "*",
      p.value < 0.1   ~ ".",
      TRUE            ~ ""
    )
  )

poisson_tbl |>
  dplyr::select(term, estimate, std.error, statistic, p.value, signif) |>
  dplyr::slice(1:12)
```

```{r poisson-metrics, echo=FALSE, message=FALSE, warning=FALSE}
pseudo_r2 <- 1 - (glm_poisson$deviance / glm_poisson$null.deviance)
dispersion <- sum(stats::residuals(glm_poisson, type = "pearson")^2) / glm_poisson$df.residual
aic_val <- AIC(glm_poisson)

data.frame(
  AIC = aic_val,
  pseudo_R2_deviance = pseudo_r2,
  dispersion_pearson = dispersion
)
```

If the **dispersion** is clearly above 1, the Poisson variance assumption
(mean ≈ variance) may be violated (overdispersion). In a real use case you’d
consider a quasi-Poisson or negative binomial model. We keep Poisson here for
comparability and interpretation practice.

### 6.3 Interpretation of selected coefficients

In a Poisson GLM with log link:

- `exp(beta) > 1` → expected count increases  
- `exp(beta) < 1` → expected count decreases  
- percent change: `(exp(beta) - 1) * 100`

```{r poisson-effects, echo=FALSE, message=FALSE, warning=FALSE}
effects_tbl <- broom::tidy(glm_poisson) |>
  dplyr::mutate(
    rate_ratio = exp(estimate),
    pct_change = (rate_ratio - 1) * 100
  )

selected_terms <- c("age", "accident_bin", "transmissionManual", "fuel_typeElectric")

effects_tbl |>
  dplyr::filter(term %in% selected_terms) |>
  dplyr::select(term, estimate, rate_ratio, pct_change, p.value) |>
  dplyr::mutate(
    rate_ratio = round(rate_ratio, 3),
    pct_change = round(pct_change, 1)
  )
```

### 6.4 Residual diagnostics

```{r poisson-residual-plot, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(glm_poisson_data, aes(x = pred_milage_k, y = resid_milage_k)) +
  geom_point(alpha = 0.4) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    x = "Predicted milage_k_count",
    y = "Residual (observed - predicted)",
    title = "Poisson GLM: residuals vs. predicted values"
  )
```

### 6.5 Conclusions (Poisson GLM)

The Poisson GLM demonstrates how to model a count-like response with a log link
and interpret effects as multiplicative changes via `exp(beta)`. While
`milage_k_count` is not a true event count, this workflow is useful to practice
GLM estimation, interpretation, and basic diagnostics. In a real client setting
with genuine count outcomes, overdispersion should be checked carefully and a
quasi-Poisson or negative binomial model may be more appropriate.
